generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String    @id
  name           String
  email          String
  emailVerified  Boolean
  deleted        Boolean   @default(false)
  phone          String?   @unique
  gender         Gender?
  birthday       DateTime?
  country        String?
  city           String?
  languages      String[]
  educationLevel String?
  occupation     String?
  incomeLevel    String?
  interests      String[]
  image          String?
  createdAt      DateTime
  updatedAt      DateTime
  sessions       Session[]
  accounts       Account[]

  role         Role?
  banned       Boolean?
  banReason    String?
  banExpires   DateTime?
  Survey       Survey[]
  Answer       Answer[]
  Wallet       Wallet[]
  Payment      Payment[]
  Subscription Subscription[]
  Response     Response[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Survey {
  id             String       @id @default(uuid())
  creatorId      String
  title          String
  description    String
  target         Json?
  reward         Float
  participant    Int
  maxParticipant Int
  status         SurveyStatus @default(draft)
  expireDate     DateTime
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  user User @relation(fields: [creatorId], references: [id])

  question Question[]

  Response Response[]
}

model Question {
  id          String   @id @default(uuid())
  surveyId    String
  type        String
  label       String
  placeholder String?
  required    Boolean  @default(false)
  validation  Json?
  options     Json?
  order       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  survey Survey @relation(fields: [surveyId], references: [id])

  answer Answer[]
}

model Answer {
  id         String   @id @default(uuid())
  questionId String
  userId     String
  answer     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  question Question @relation(fields: [questionId], references: [id])
  user     User     @relation(fields: [userId], references: [id])
}

model Response {
  id       String @id @default(uuid())
  surveyId String
  userId   String

  user   User   @relation(fields: [userId], references: [id])
  survey Survey @relation(fields: [surveyId], references: [id])
}

model Wallet {
  id         String @id @default(uuid())
  userId     String
  balance    Float
  totalEarn  Float
  totalSpend Float

  user User @relation(fields: [userId], references: [id])
}

model Payment {
  id            String        @id @default(uuid())
  userId        String
  type          PaymentType
  amount        Float
  currency      String        @default("ETB")
  status        PaymentStatus
  transactionId String?
  metadata      Json?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model SubscriptionPlan {
  id           String @id @default(uuid())
  name         String
  price        Float
  maxSurvey    String
  timePeriod   Int
  refundPeriod Int

  Subscription Subscription[]
}

model Subscription {
  id        String   @id @default(uuid())
  userId    String
  startDate DateTime @default(now())
  endDate   DateTime
  plan      String
  usage     Int      @default(0)

  user             User             @relation(fields: [userId], references: [id])
  subscriptionType SubscriptionPlan @relation(fields: [plan], references: [id])
}

enum Role {
  user
  creator
  admin
}

enum Gender {
  male
  female
}

enum SurveyStatus {
  pending
  live
  ended
  rejected
  draft
}

enum PaymentType {
  fund
  withdraw
  subscribe
  refund
}

enum PaymentStatus {
  pending
  success
  failed
  cancelled
  error
}
